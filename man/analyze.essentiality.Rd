% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/essentiality.R
\name{analyze.essentiality}
\alias{analyze.essentiality}
\title{Gene essentiality scoring.}
\usage{
analyze.essentiality(id = NULL, sgRNA_reps = NULL, annotation = NULL,
  uniform.weights = FALSE, empirical.weights = FALSE,
  read.filtered = FALSE, filtered.essential = NULL,
  filtered.nonessential = NULL, filtered.reps = NULL, shinyF = NULL)
}
\arguments{
\item{id}{an identifier for the analysis. All input will be read from and all output will be stored in a directory with this name. If \code{NULL}, two data frames must be supplied containing the sgRNA-level log-fold-changes per replicate and annotation. Defaults to \code{NULL}.}

\item{sgRNA_reps}{an optional data frame containing the sgRNA log-fold-changes for each replicate. If \code{NULL}, the log-fold-change file generated previously will be read.}

\item{annotation}{an optional data frame containing the sample annotation information. If \code{NULL}, the annotation file generated previously will be read.}

\item{uniform.weights}{logical. Should uniform weight values be used for sgRNA weighted averaging? Defaults to \code{FALSE}.}

\item{empirical.weights}{logical. Should empirical weight values be used for sgRNA weighted averaging? Defaults to \code{FALSE}.}

\item{read.filtered}{logical. Should the filtered list of control genes generated by the 2-tail RRA algorithm be used to optimize the regression parameters? Requires an identifier to be set, otherwise use \code{filtered.essential} and \code{filtered.nonessential} instead. Defaults to \code{FALSE}.}

\item{filtered.essential}{an optional vector of names for filtered essential genes. Takes precedence over \code{read.filtered}. Defaults to \code{NULL}.}

\item{filtered.nonessential}{an optional vector of names for filtered non-essential genes. Takes precedence over \code{read.filtered}. Defaults to \code{NULL}.}

\item{filtered.reps}{an optional vector of names for filtered sample names. Defaults to \code{NULL}.}

\item{shinyF}{logical. An internal parameter used by the graphical user interface. If using command-line leave as \code{NULL}.}
}
\value{
A list containing the following components:
\item{scored_reps}{gene scores for each replicate.}
\item{scored}{replicate-averaged gene scores.}
\item{weights, scaling and shifting}{the optimized final regression parameters employing the selected control genes whose size is equal to the most frequent gene size in the dataset. If not applicable, returns \code{NULL}.}
}
\description{
Generates gene essentiality scores for each condition in the sample annotation file.
}
\details{
The gene-scoring parameters are first optimized for those genes whose size is equal to the most frequent gene size.
Genes with a larger size are scored by bootstrap-aggregating them 10 times so that the size of each bootstrap is equal to the most frequent size, and the same parameters are used.
Genes with smaller size are scored by generating 10 sets of scoring parameters from bootstrapping the control genes for each gene size, and afterwards bootstrap-aggregating the scores from each set.
The posibility of employing filtered sets of control genes requires running the 2tail RRA module beforehand. \cr

If \code{id} is not \code{NULL}, the following files are produced in the directory with name equal to the identifier:
\itemize{
 \item{\code{scored_reps.txt} and \code{scored.txt}, containing the gene-level scores for each condition before and after averaging the replicates.}
 \item{\code{scored_weights.txt}, \code{scored_scaling.txt} and \code{scored_shifting.txt}, the optimized final regression parameters employing the selected control genes whose size is equal to the most frequent gene size in the dataset. Only produced if \code{empirical.weights} is set to \code{TRUE}}
}
}
\examples{

## Example I. Generating output files through an analysis identifier:

## 1. Prepare read counts information:
counts <- read.counts(id="DANG_CCK81", counts=MoPAC::dang_cck81, library=MoPAC::sgRNA_library)

## 2. Manually fill out either of the two annotation files produced by read.counts.
## In this example we will fill it out using R:
annotation <- counts$Annotation
annotation$Condition <- c("Plasmid0","Plasmid1",rep("DANG",4),rep("CCK81",3))
annotation$Replicate <- c("A","A","A","B","C","D","A","B","C")
annotation$Control <- c("","",rep("Plasmid0",4),rep("Plasmid1",3))
utils::write.csv(annotation,"DANG_CCK81/annotation.csv",quote=FALSE,row.names=FALSE)

## 3. Get pre-processed fold changes:
qc <- quality.control(id="DANG_CCK81", report=FALSE)

## 4. Optionally do two-tail RRA essentiality analysis for control gene filtering:
significance <- RRA.2tail(id="DANG_CCK81")

## 5. Gene essentiality analysis:
scores <- analyze.essentiality(id="DANG_CCK81",empirical.weights=TRUE)

## Example II. Returning a data frame without generating output:

## 1. Prepare read counts information:
counts <- read.counts(counts=MoPAC::dang_cck81, library=MoPAC::sgRNA_library)

## 2. Prepare sample annotation as a data frame:
annotation <- counts$Annotation
annotation$Condition <- c("Plasmid0","Plasmid1",rep("DANG",4),rep("CCK81",3))
annotation$Replicate <- c("A","A","A","B","C","D","A","B","C")
annotation$Control <- c("","",rep("Plasmid0",4),rep("Plasmid1",3))

## 3. Get pre-processed fold changes:
qc <- quality.control(counts=counts$Counts, annotation=annotation)

## 4. Optionally do two-tail RRA essentiality analysis:
significance <- RRA.2tail(sgRNA=qc$sgRNA_lfc)

## 5. Gene essentiality analysis:
essentiality <- analyze.essentiality(sgRNA_reps=qc$sgRNA_lfc_reps,
                                     empirical.weights=TRUE, annotation=annotation)

##--------------------------------------------------------------------------------------

}
\author{
Oscar D Villarreal, \email{oscardvillarreal@gmail.com}
}
\keyword{essentiality}
