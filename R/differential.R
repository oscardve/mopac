#' @title Gene differential essentiality scoring.
#'
#' @description Normalizes the distributions of one pair of conditions and generates differential gene essentiality scores.
#'
#' @param id an optional identifier for the analysis. All input will be read from and all output will be stored in a directory with this name. If \code{NULL}, two data frames must be supplied containing the counts and annotation. Defaults to \code{NULL}.
#' @param sgRNA an optional data frame containing the sgRNA-level log-fold-changes for the replicate-averaged conditions. If \code{NULL}, the file 'sgRNA_lfc.txt' generated previously will be read.
#' @param scored_reps an optional data frame containing the gene-level scores for each replicate. If \code{NULL}, the file 'scored_reps.txt' generated previously will be read.
#' @param annotation an optional data frame containing the sample annotation information. If \code{NULL}, the annotation file generated previously will be read.
#' @param condition1 name of first condition (i.e. any of the column names in the scored.txt file). Defaults to the first condition.
#' @param condition2 name of second condition (i.e. any of the column names in the scored.txt file). Defaults to the second condition.
#' @param read.unenriched logical. Should the filtered list of unenriched genes generated by the 2-tail RRA algorithm be used to perform the normalization? Requires an identifier to be set, otherwise please use \code{unenriched} instead. Defaults to \code{FALSE}.
#' @param unenriched an optional vector of names for filtered unenriched genes. Use it instead of \code{read.unenriched} when the \code{id} is set to \code{NULL}. Defaults to \code{NULL}.
#' @param report logical. Should an html report of top-ranking differentially essential genes be generated? Requires an identifier to be set, and both pandoc and plotly installation. Defaults to \code{FALSE}.
#'
#' @details
#' The distributions of gene scores are first normalized in the following way: (1) If \code{read.unenriched} is \code{FALSE}, then the combination of essential and nonessential genes are quantile-normalized; if it is \code{TRUE}, then the unenriched genes are quantile-normalized, this is recommended if the amount of controls is small. (2) A quantile-quantile plot is fitted to the transformation before and after the normalization. (3) A smoothing spline is fitted to the quantile-quantile plot. (4) The smoothing spline is used to interpolate the transformation of the gene scores which corresponds to the normalization of step 1.
#'
#' After the gene scores are normalized, a Z score is used to rank the genes according to differential essentiality between the two conditions. A P value is also obtained from the replicate information of each gene.
#'
#' If \code{id} is not \code{NULL}, the following files are produced in the directory with name equal to the identifier:
#' \itemize{
#'  \item{\code{condition1_condition2_normalized_reps.txt}, containing the gene-level normalized scores for the replicates of both conditions.}
#'  \item{\code{condition1_condition2_differential.txt}, the relative difference statistic for the pair of conditions selected.}
#' }
#'
#' @return A data frame containing the MoPAC differential gene essentiality scores of the two selected conditions.
#'
#' @author Oscar D Villarreal, \email{oscardvillarreal@gmail.com}
#' @keywords differential essentiality
#'
#' @examples
#'
#' ## Example I. Generating output files through an analysis identifier:
#'
#' ## 1. Prepare read counts information:
#' counts <- read.counts(id="DANG_CCK81", counts=MoPAC::dang_cck81, library=MoPAC::sgRNA_library)
#'
#' ## 2. Manually fill out either of the two annotation files produced by read.counts.
#' ## In this example we will fill it out using R:
#' annotation <- counts$Annotation
#' annotation$Condition <- c("Plasmid0","Plasmid1",rep("DANG",4),rep("CCK81",3))
#' annotation$Replicate <- c("A","A","A","B","C","D","A","B","C")
#' annotation$Control <- c("","",rep("Plasmid0",4),rep("Plasmid1",3))
#' utils::write.csv(annotation,"DANG_CCK81/annotation.csv",quote=FALSE,row.names=FALSE)
#'
#' ## 3. Get pre-processed fold changes:
#' qc <- quality.control(id="DANG_CCK81", report=FALSE)
#'
#' ## 4. Optionally do two-tail RRA essentiality analysis for control gene filtering:
#' significance <- RRA.2tail(id="DANG_CCK81")
#'
#' ## 5. Gene essentiality analysis:
#' scores <- analyze.essentiality(id="DANG_CCK81",empirical.weights=TRUE)
#'
#' ## 6. Gene differential essentiality analysis:
#' ## a) If there are only two conditions, there's no need to specify them:
#' differential <- analyze.differential(id="DANG_CCK81", read.unenriched=TRUE, report=FALSE)
#'
#' ## c) If there are more than two conditions, please select two of them explicitly:
#' differential <- analyze.differential(id="DANG_CCK81", read.unenriched=TRUE,
#'                 condition1="DANG", condition2="CCK81", report=FALSE)
#'
#' ## Example II. Returning a data frame without using an identifier to generate output:
#'
#' ## 1. Prepare read counts information:
#' counts <- read.counts(counts=MoPAC::dang_cck81, library=MoPAC::sgRNA_library)
#'
#' ## 2. Prepare sample annotation as a data frame:
#' annotation <- counts$Annotation
#' annotation$Condition <- c("Plasmid0","Plasmid1",rep("DANG",4),rep("CCK81",3))
#' annotation$Replicate <- c("A","A","A","B","C","D","A","B","C")
#' annotation$Control <- c("","",rep("Plasmid0",4),rep("Plasmid1",3))
#'
#' ## 3. Get pre-processed fold changes:
#' qc <- quality.control(counts=counts$Counts, annotation=annotation, report=FALSE)
#'
#' ## 4. Optionally do two-tail RRA essentiality analysis for control gene filtering:
#' significance <- RRA.2tail(sgRNA=qc$sgRNA_lfc)
#'
#' ## 5. Gene essentiality analysis:
#' scores <- analyze.essentiality(sgRNA_reps=qc$sgRNA_lfc_reps,empirical.weights=TRUE,
#'                                annotation=annotation)
#'
#' ## 6. Gene differential essentiality analysis:
#' ## a) If there are only two conditions, there's no need to specify them:
#' differential <- analyze.differential(scored_reps=scores$scored_reps,
#'    sgRNA=qc$sgRNA_lfc, annotation=annotation,
#'    unenriched=significance$Unenriched, report=FALSE)
#'
#' ## b) If there are more than two conditions, please select two of them explicitly:
#' differential <- analyze.differential(scored_reps=scores$scored_reps,
#'    sgRNA=qc$sgRNA_lfc, annotation=annotation,
#'    unenriched=significance$Unenriched,
#'    condition1="DANG", condition2="CCK81", report=FALSE)
#'
#' ##--------------------------------------------------------------------------------------
#'
#' @export
#'

analyze.differential <- function(id=NULL,sgRNA=NULL,scored_reps=NULL,annotation=NULL,condition1=NULL,condition2=NULL,read.unenriched=FALSE,unenriched=NULL,report=FALSE) {
  set.seed(123)
  print("Importing data...")
  # Read sgRNA-level replicate-averaged log-fold-changes ----------------------------------------------------
  if(is.null(id) & is.null(sgRNA)) { # insufficient information provided
    stop("Please specify a working directory or provide the replicate-averaged sgRNA log-fold-changes.")
  } else if(!is.null(id) & is.null(sgRNA)) { # is a table of read sgRNA_reps available in the working directory?
    if(file.exists(paste0(id,"/sgRNA_lfc.txt"))) {
      sgRNA <- utils::read.table(paste0(id,"/sgRNA_lfc.txt"),header=TRUE,sep="\t",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE)
    } else stop("Please provide the replicate-averaged sgRNA log-fold-changes generated by the quality control module.")
  } else if(is.data.frame(sgRNA)) { # was a data frame provided as a table of read counts?
    sgRNA <- sgRNA
    sgRNA[,sapply(sgRNA,is.factor)] <- sapply(sgRNA[,sapply(sgRNA,is.factor)],as.character)
    # colnames(counts0) <- stringr::str_replace_all(colnames(counts0),"[^[:alnum:]]","") #remove non-alphanumeric characters in the sample names
  } else if(is.character(sgRNA)) { # was a file path provided?
    if(file.exists(sgRNA)) {
      sgRNA <- utils::read.table(sgRNA,header=TRUE,sep="\t",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE)
    } else stop("sgRNA replicate-averaged log-fold-change file not found in the specified address.")
  } else stop("Please provide a valid table of replicate-averaged sgRNA log-fold-changes.")
  if(!"sgRNA"%in%colnames(sgRNA) | !"Gene"%in%colnames(sgRNA))
    stop("Please run the quality control module first.")
  # Read gene essentiality scores  -------------------------------------------------------------------------------
  if(is.null(id) & is.null(scored_reps)) { # insufficient information provided
    stop("Please specify a working directory or provide the gene scores and sample annotation.")
  } else if(!is.null(id) & is.null(scored_reps)) { # is a table of read scored_reps available in the working directory?
    if(file.exists(paste0(id,"/scored_reps.txt"))) {
      scored_reps0 <- utils::read.table(paste0(id,"/scored_reps.txt"),header=TRUE,sep="\t",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE)
      # } else if(file.exists(paste0(id,"/fastq_scored_reps.txt"))) {
      #   sgRNA <- utils::read.table(paste0(id,"/fastq_scored_reps.txt"),header=TRUE,sep="\t",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE)
    } else stop("Please provide the scores for each replicate and sample annotation generated by the quality control module.")
  } else if(is.data.frame(scored_reps)) { # was a data frame provided as a table of read scored_reps?
    scored_reps0 <- scored_reps
    scored_reps0[,sapply(scored_reps0,is.factor)] <- sapply(scored_reps0[,sapply(scored_reps0,is.factor)],as.character)
    # colnames(sgRNA) <- stringr::str_replace_all(colnames(sgRNA),"[^[:alnum:]]","") #remove non-alphanumeric characters in the sample names
  } else if(is.character(scored_reps)) { # was a file path provided as a table of read scored_reps?
    if(file.exists(scored_reps)) {
      scored_reps0 <- utils::read.table(scored_reps,header=TRUE,sep="\t",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE)
    } else stop("Scores file not found in the specified address.")
    # colnames(sgRNA) <- stringr::str_replace_all(colnames(sgRNA),"[^[:alnum:]]","") #remove non-alphanumeric characters in the sample names
  } else stop("Please provide a valid table of gene scores.")
  if(!"Gene"%in%colnames(scored_reps0))
    stop("Please run the gene essentiality module first.")
  # Read annotation -------------------------------------------------------------------------
  if(is.null(id) & is.null(annotation)) { # insufficient information provided
    stop("Please specify a working directory or provide a data frame of annotation.")
  } else if(!is.null(id) & is.null(annotation)) { # is a table of annotation available in the working directory?
    if(file.exists(paste0(id,"/annotation.csv"))) {
      annotation0 <- utils::read.csv(paste0(id,"/annotation.csv"),header=TRUE,as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE,comment.char="",quote="\"",na.strings="")
      if(sum(is.na(annotation0[,-which(colnames(annotation0)%in%"Control")]))>0)
        annotation0 <- openxlsx::read.xlsx(paste0(id,"/annotation.xlsx"),check.names=FALSE,na.strings="")
      if(sum(is.na(annotation0[,-which(colnames(annotation0)%in%"Control")]))>0)
        stop("Please fill out the sample file annotation before proceeding.")
    } else stop("Please provide a table of annotation or run the previous modules first.")
  } else if(is.data.frame(annotation)) { # was a data frame provided as a table of read counts?
    annotation0 <- annotation
    annotation0[,sapply(annotation0,is.factor)] <- sapply(annotation0[,sapply(annotation0,is.factor)],as.character)
  }  else if(is.character(annotation)) {
    if(file.exists(annotation)) {
      if(tools::file_ext(annotation)=="xlsx") {
        annotation0 <- openxlsx::read.xlsx(annotation,check.names=FALSE,na.strings="")
      } else if(tools::file_ext(annotation)=="csv") {
        annotation0 <- utils::read.csv(annotation,header=TRUE,as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE,comment.char="",quote="\"",na.strings="")
      } else annotation0 <- utils::read.table(annotation,header=TRUE,as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE,comment.char="",quote="\"",na.strings="")
    } else stop("Annotation file not found in the specified address.")
    if(sum(is.na(annotation0[,-which(colnames(annotation0)%in%"Control")]))>0)
      stop("Please fill out the sample file annotation before proceeding.")
  } else stop("The annotation object provided could not be read.")
  if(sum(!c("Sample","Condition","Replicate","Control")%in%colnames(annotation0))>0)
    stop("Please make sure the annotation contains the columns: Sample, Condition, Replicate and Control")
  annotation1 <- annotation0[annotation0$Sample%in%colnames(scored_reps0),]
  if(nrow(annotation1)==0)
    stop("Mismatch found between the annotation samples and the sgRNA column names.")
  # Find conditions:
  # annotation1 <- unique(annotation[annotation$Timepoint>0,c("Sample","Cell_line","Treatment","Timepoint","Replicate")])
  # annotation1$Condition <- paste0(annotation1$Cell_line,".",annotation1$Treatment,".",annotation1$Timepoint)
  conditions <- unique(annotation1$Condition)
  if(is.null(condition1) | is.null(condition2)) {
    if(length(conditions)>1) {
      condition1 <- conditions[1]
      condition2 <- conditions[2]
    } else stop("A minimum of two conditions are necessary for differential essentiality analysis.")
  } else if(!condition1%in%annotation1$Condition | !condition2%in%annotation1$Condition)
    stop("Selected conditions not found. Please make sure that they exist in the 'Condition' column of the annotation file.")
  samples1 <- as.character(annotation1$Sample[annotation1$Condition==condition1])
  samples2 <- as.character(annotation1$Sample[annotation1$Condition==condition2])
  # Normalization  ---------------------------------------------------------------------------------------------------------
  # At the gene level the normalization is made before averaging the replicates, since the quality is better.
  # At the sgRNA level the normalization is made after averaging the replicates, since it is noisier.
  print("Normalizing conditions...")
  # Extract the unenriched or the control genes:
  if(!is.null(unenriched)) {
    controls1 <- controls0 <- scored_reps0[scored_reps0$Gene%in%unenriched,c(samples1,samples2)] #extract unenriched genes from input
    controls1_sgRNA <- controls0_sgRNA <- sgRNA[sgRNA$Gene%in%unenriched,c(condition1,condition2)] #extract unenriched genes from input
  } else if(read.unenriched==TRUE) {
    if(!file.exists(paste0(id,"/unenriched.txt")))
      stop(paste0("File ",id,"/unenriched.txt not found."))
    unenriched <- utils::read.table(paste0(id,"/unenriched.txt"),header=TRUE,sep="",as.is=TRUE,check.names=FALSE,stringsAsFactors=FALSE,row.names=NULL)[,1]
    controls1 <- controls0 <- scored_reps0[scored_reps0$Gene%in%unenriched,c(samples1,samples2)] #extract unenriched genes from file
    controls1_sgRNA <- controls0_sgRNA <- sgRNA[sgRNA$Gene%in%unenriched,c(condition1,condition2)] #extract unenriched genes from input
  } else if("Category"%in%colnames(scored_reps0)) {
    controls1 <- controls0 <- scored_reps0[scored_reps0$Category%in%c("Essential","Nonessential"),c(samples1,samples2)] #extract controls
    controls1_sgRNA <- controls0_sgRNA <- sgRNA[sgRNA$Category%in%c("Essential","Nonessential"),c(condition1,condition2)] #extract controls
  } else stop("Please make read.unenriched TRUE or supply a column of 'Category'")
  # Quantile normalize the extracted genes and interpolate to the other genes:
  controls1[,names(controls0)] <- get_quantile(as.matrix(controls0))
  normed <- scored_reps0[,which(colnames(scored_reps0)%in%c("Gene","Category",samples1,samples2))]
  for(i in c(samples1,samples2)) {
    QQ <- as.data.frame(stats::qqplot(x=controls0[,i],y=controls1[,i],plot.it=FALSE))
    fit <- stats::smooth.spline(x=QQ$x,y=QQ$y,spar=1)
    normed[,i] <- stats::predict(fit,scored_reps0[,i])$y
  }
  # Quantile normalize the sgRNAs targeting the extracted genes and interpolate to the other sgRNAs:
  controls1_sgRNA[,names(controls0_sgRNA)] <- get_quantile(as.matrix(controls0_sgRNA))
  normed_sgRNA <- sgRNA[,which(colnames(sgRNA)%in%c("sgRNA","Gene","Category",condition1,condition2))]
  for(i in c(condition1,condition2)) {
    QQ <- as.data.frame(stats::qqplot(x=controls0_sgRNA[,i],y=controls1_sgRNA[,i],plot.it=FALSE))
    fit <- stats::smooth.spline(x=QQ$x,y=QQ$y,spar=1)
    normed_sgRNA[,i] <- stats::predict(fit,sgRNA[,i])$y
  }
  # Replicate average, Z score, p value and FDR -----------------------------------------------------------------------------
  print("Computing Z score...")
  # Averaged biased scores (only used for visualization):
  # scored <- cbind(scored_reps0[,which(colnames(scored_reps0)%in%c("Gene","Category")),drop=F],
  #                 rowMeans(scored_reps0[,samples1,drop=FALSE]),
  #                 rowMeans(scored_reps0[,samples2,drop=FALSE]))
  # colnames(scored)[(ncol(scored)-1):ncol(scored)] <- c(condition1,condition2)
  # Avergaed unbiased scores:
  averaged <- cbind(normed[,which(colnames(normed)%in%c("Gene","Category")),drop=F],
                    rowMeans(normed[,samples1,drop=FALSE]),
                    rowMeans(normed[,samples2,drop=FALSE]))
  colnames(averaged)[(ncol(averaged)-1):ncol(averaged)] <- c(condition1,condition2)
  # Z score and t test with FDR:
  N1 <- length(samples1); N2 <- length(samples2)
  analyzed <- cbind(averaged,Z=averaged[,condition1]-averaged[,condition2])
  analyzed$Z <- (analyzed$Z-stats::median(analyzed$Z)) / stats::mad(analyzed$Z,constant=1.4826) #the Z score is estimated by the MAD
  analyzed$`P(-)` <- stats::pnorm(analyzed$Z,lower.tail=TRUE)
  analyzed$`FDR(-)` <- stats::p.adjust(analyzed$`P(-)`,"fdr")
  analyzed$`P(+)` <- stats::pnorm(-1*analyzed$Z,lower.tail=TRUE)
  analyzed$`FDR(+)` <- stats::p.adjust(analyzed$`P(+)`,"fdr")
  if(N1>1 & N2>1) {
    analyzed$`P(replicates)` <- apply(normed[,-which(colnames(normed)%in%c("Gene","Category"))],1,
                                           function(x)stats::t.test(x[1:N1],x[(N1+1):(N1+N2)])$p.value)
    analyzed$`FDR(replicates)` <- stats::p.adjust(analyzed$`P(replicates)`,"fdr")
  }
  # P value from normalized sgRNAs:
  print("Computing P value...")
  normed_sgRNA$Z <- normed_sgRNA[,condition1]-normed_sgRNA[,condition2]
  normed_sgRNA$Z <- (normed_sgRNA$Z-stats::median(normed_sgRNA$Z)) / stats::mad(normed_sgRNA$Z,constant=1.4826) #the Z score is estimated by the MAD
  p_sgRNA <- getPValues(normed_sgRNA$Gene,normed_sgRNA$sgRNA,normed_sgRNA$Z,0.5)
  colnames(p_sgRNA)[ncol(p_sgRNA)] <- "P(sgRNAs)"
  analyzed <- merge(analyzed,p_sgRNA[,c("Gene","P(sgRNAs)")])
  analyzed$`FDR(sgRNAs)` <- stats::p.adjust(analyzed$`P(sgRNAs)`,"fdr")
  analyzed <- analyzed[order(analyzed$Z),]
  # Output  --------------------------------------------------------------------------------------------------------------
  if(!is.null(id)) {
    utils::write.table(normed,paste0(id,"/",condition1,"_",condition2,"_normalized_reps.txt"),quote=FALSE,sep='\t',row.names=FALSE,col.names=TRUE)
    utils::write.table(analyzed,paste0(id,"/",condition1,"_",condition2,"_differential.txt"),quote=FALSE,sep='\t',row.names=FALSE,col.names=TRUE)
    if(report==TRUE) {
      if("plotly" %in% rownames(utils::installed.packages()) == TRUE) {
        print("Generating analysis report...")
        rmarkdown::render(system.file("rmd/differential.Rmd",package="MoPAC"),output_file=paste0(condition1,"_",condition2,"_differential.html"),output_dir=id,#intermediates_dir=id,knit_root_dir=id,
                          params = list( #paste0(getwd(),"/",id)
                            condition1 = condition1,
                            condition2 = condition2,
                            # scored = averaged,
                            analyzed = analyzed
                          ))
      } else print("plotly installation not found.")
    }
  }
  print("Done.")
  return(list(sgRNA=normed_sgRNA,Gene=analyzed))
}


